https://jsonplaceholder.typicode.com/users
https://jsonplaceholder.typicode.com/posts
localhost:3001/posts

En este archivo vamos a tener la explicacion del paso a paso para levantar un servidor y una base de datos, como crear rutas y manejadores. 

Cuando hablamos del back-end los pasos son un tanto mas extensos que cuando desarrollamos el front por una cuestión que al desarrollar con Vite (front) hay muchas cosas que ya vienen armadas y configuradas por defecto. 
Pasos para desarrollar un back desde cero.

-Al crear la carpeta contenedora de todo (api) vamos a instalar un package.json en ella, para en este archivo, poder instalar todas las dependencias que podamos necesitar.

-Creamos la carpeta src y dentro de ella, vamos a crear el archivo app.js (este archivo tendra la responsabilidad de tener la configuración del servidor express) app tendra la responsabilidad de tener la configuracion del servidor, ojo NO de levantar el servidor, si no, de tener su configuración. 

1- Dentro de app hacemos los pasos de siempre: requerir a expres, crear una variable con ese contenido requerido para poder manipular, y exportar dicha variable.

2-Dentro del index.js (archivo que esta dentro de la carpeta api) vamos a llamar a app pero lo vamos a renombrar a server (para que tenga más sentido el actuar.).

3-Vamos a utilizar el método LISTEN de expres para poner a escuchar al puerto 3001, puerto que crearemos con una variable y pondremos a escuchar con sus dos parametros (el puerto y la callback). En este caso el callback será un console.log qeu simplemente nos demuestre que al levantar el servidor, se ejecutará correctamente. 

A)- Ahora en nuestro servidor(app.js):

1- Vamos a configurar morgan. (const morgan = require("morgan");)

2- Vamos a utilizar el metodo use que nos brinda express para decirle a: app que vamos a USAR morgan en la parte de dev.

3- Vamos a crear una simple ruta de practica con un status 200 con el mensaje: "Se que oyes mis pensamientos muchacho".

4- Vamos a crear otra ruta de prueba pero esta vez, vamos a pasar un nombre de usuario y un id por params. Cuando en el código estemos leyendo: 
const { id } = req.params;
const { usuario } = req.params;

 lo que estamos haciendo es que estamos desestructurando el nombre del usuario y el id que le esta llegando a la URL por params para que estos puedan ser dinámicos. Es decir, si por la url nosotros le mandamos:

  ---> localhost:3001/users/Franco/27

Nos estaría devolviendo: (teniendo en cuenta el .send que nosotros programemos en la request)

  ---> El usuario: Franco con el id: 27 

Donde vemos que hay un comentario: console.log("REQ", req) es para ver lo que nos devuelve por consola gracias a DEV de morgan. Podemos ver que req es un objeto muy grande con muchas propiedades.

Diferencias de Query y params: 

Query (consulta) string:
En una URL, el query string es la parte que sigue al signo de interrogación (?). Los datos se pasan como pares clave-valor separados por el signo de igual (=``) y separados por el signo ampersand (&`). Por ejemplo:

arduino

https://ejemplo.com/pagina?nombre=Juan&edad=25

Ventajas:

    Fácil de entender y depurar, ya que los datos son visibles en la URL.
    Puede ser compartido y marcado como favorito.

Desventajas:

    Limitado en la cantidad de datos que se pueden transmitir.
    Los datos son visibles en la URL, lo que puede ser un problema si se trata de información sensible.

Parámetros en la URL:
En este enfoque, los datos se incluyen directamente en la URL, siguiendo una estructura específica. Por ejemplo:

bash

https://ejemplo.com/pagina/valor1/valor2

Ventajas:

    Puede verse más limpio y semántico en comparación con una cadena de consulta.
    Al igual que con la cadena de consulta, es fácil de entender y depurar.

Desventajas:

    También está limitado en la cantidad de datos que se pueden transmitir.
    Puede no ser adecuado para datos sensibles.


B)- Si continuamos creando rutas en el archivo app.js vamos a ver que cada vez se hace mas extenso, cada vez que creamos rutas, se pone muy denso el poder leer ya que serán muchas. Para resolver este problema, comenzaremos a modularizar. 

1- Vamos a crear una carpeta para las rutas llamada routes.

2- Dentro de ella, crearemos un enrutador llamada mainRouter.js (en el PI lo tenemos como index.js) pero nosotros lo llamaremos mainRouter ya que serán las rutas principales. 

3- Lo primero que debemos hacer es traernos a Router: const { Router } = require("express") donde y como bien sabemos, router es un Middleware, es un sistema de Middleware y direccionamiento, se utiliza para realizar el direccionamiento de las otras rutas. 

4- Crearemos una variable llamada mainRouter que sea igual a la ejecución de nuestro Router, para poder tener todos los métodos de Router.

5- Ahora si nos traeremos las consultas de app. Ya que habiamos dicho que app solo tendrá la configuración del servidor, asique no necesitamos que tenga la responsabilidad de las consultas. 

6- Apenas peguemos todas las consultas, tendremos que cambiar la palabra app (app.get ; app.post ; etc) por mainRouter.

---
  Si tenemos todo cambiado de lugar a sus respectivas responsabilidades y hacemos una req de tipo get al postman nos aparecerá un error, pese a que esta todo bien. Falta algo: 
---

7- En el archivo app.js tenemos que decirle que, de la misma forma que usamos el método USE para decirle a app que vamos a USAR a morgan, ahora tambien le tenemos que avisar que vamos a USAR a mainRouter y esto lo hacemos tanto en donde lo requerimos y donde lo encontramos y debajo de morgan usando el USE.

8- Vamos a crear una nueva ruta dirigida a los posteos de los usuarios. Las URL que vamos a manejar son: 
https://jsonplaceholder.typicode.com/users 
https://jsonplaceholder.typicode.com/posts

Dicha ruta va a ser de tipo get con un status 200 y un mensaje enviado que diga: Posts Ok.


C)- Nos vamos a encontrar con otro problema, en este archivo (mainRouter.js) vamos a tener muchas request de tipo post, get, put, tal vez delete, con lo cual se va a conformar otro inconveniente de orden y sintaxis. 

1- Dentro de la carpeta router vamos a crear un archivo para las rutas de los usuarios (usersRouter.js), otro archivo exclucivamente oara las rutas de los posteos (postsRouter)

2- Vamos a continuar modularizando, en el archivo usersRouter vamos a hacer practicamente lo mismo que hicimos en el mainRouter: 
- Nos traemos al router.
- Creamos nuestra variable de usersRouter que utilizara a router y obviamente lo exportamos.
- Copiamos las rutas de users del archivo mainRouter y las pegamos en su archivo correspondiente (usersRouter)
- Hacemos lo mismo con el archivo post y sus rutas.
- MUY IMPORTANTE, no olvidar cambiar el nombre de las variables, es decir: Cuando pasamos una ruta del mainRouter al archivo usersRouter no olvidar cambiar:

mainRouter.post("...  

a : 

userRouter.post("/users", (req, res) => {
 res.status(201).send("Usuario creado de forma fraudulenta");
});

y lo mismo para el archivo postsRouter.

3- Al haber modularizado todo, en el archivo mainRouter le tenemos que avisar donde va a encontrar la informacion llegado el caso que hagan una req a posts o users. Donde: Primero requerimos estos archivos vinculados a una nueva variable y segundo, con el metodo use, le decimos a mainRouter que USE estas varuables que contienen en endpoint. 

D)- Vamos a crear una carpeta llamada handlers donde, logicamente, estarán alojados todos los handlers, recordando que los handlers son los que enviaran toda la info al servidor 
1- Vamos a crear dos archivos dentro de nuestra carpeta llamados: postsHandler.js y userHandler.js 
2- Recordando que los handlers son funciones que le envian al servidor la respuesta. En el archivo userHandler vamos a crear nuestro primer handler llamado userHandler y postsHandler. NO OLVIDAR exportar, aca vamos a exportar en forma de objetos ya que vamos a exportar muchos elementos.  
3- Una vez finalizado nuestro handler de: getUserHandler estaremos en condición de poder explicar: Lo que hacen los handlers es obtener los datos que vengan por query, por body o por params y luego envia esa respuesta al cliente, además pueden manejar errores. En este caso hacen solo eso pero más adelante utilizaremos los controladores, es decir, nuestro handler llama a nuestro controlador, lo utiliza, le pasa esos datos que recibio por params, query o body y le envia la res al cliente (que ellos utilizaran la logica y se comunicaran con fuentes externas.) Ahí está la logica, los controladores hacen toda la logica, se comunican con la fuerte externa (Api o BD) y los handlers lo que hacen es utilizar esos controladores pasarle los datos, estos que recibimos por query, body o params y enviar la respuesta al cliente. 

4- Paso importante: Cambiar la sintaxis de la ruta para incorporar un Handler en ella:

  Sintaxis vieja:

  usersRouter.get("/", (req, res) => { 
    res.status(200).send("Se que oyes mis pensamientos muchacho");
}); 

Ahora (ademas de requerir el handler en la hoja de rutas vamos a decir que cuando haya un match en barra sola, utilizaremos el handler getUserHandler) a la ruta anterior le vamos a borrar el segundo parametro, la función y le vamos a agregar el handler.

  usersRouter.get("/", getUserHandler);

    " Dato a tener en cuenta: 
      Si, teniendo nuestra ruta con nuestro handler y, por ejemplo, en Postman, enviamos una peticion que diga:
      localhost:3001/users?nombre=Franco&apellido=Rosales
      Vamos a tener una respuesta de status 200 y una respuesta efectiva de servidor, pero en nuestra consola hay un error, y esto se debe a que, cuando USAMOS UN CONDICIONAL, DEBEMOS COLOCAR RETURN. Para que otorgue una respuesta y no siga con la ejecución. "

      Hacemos el paso anterior con las rutas y handler que vayamos a necesitar: Primero: Corroboramos que el handler esté siendo exportado en su hoja de origen. Segundo: Lo importamos en nuestra hoja de ruta. Tercero, se lo agregamos como segundo parametro a nuestra ruta. Cuarto: Preparamo un fernet. 

      "La diferencia más marcada entre Query y Params es que Query no cambia la ruta y Params si cambia" 
      Si nos queda alguna duda de: ¿Lo que estoy viendo esta siendo enviado por Query? Es simple, ya que nosotros desarrollamos el codigo tenemos que saber que, al momento de desarrollar en handler nosotros le especificamos al cliente que es lo que puede o no colocar, en nuestro caso le especificamos que: puede mandar nombre o apellido, en tal caso sucederá algo y si no, le contestaremos con otra cosa.  
5- Ahora vamos a desarrollar el handler de crear un Usuario el cual, recibira por body 3 parametros que nosotros, en el mismo handler, vamos a desestructurar para que sean los unicos que podamos recibir. MUY IMPORTANTE: al momento de crear esto en postman: 

Un nuevo POST por body a: http://localhost:3001/users

{
   "nombre": "Franco",
    "email": "franco@gmail.com", 
    "telefono": "15565594131"
}

Nos devolverá un error y esto se debe a que Express no entiende el formato JSON que le acabamos de brindar, para solucionar esto, necesitamos otro Middleware. Dicho middleware lo desarrollaremos en nuestro server (src - app.js)  app.use(express.json())

Con eso arreglado, el resultado será:

Creamos el usuario con el nombre: Franco correo electronico: franco@gmail.com y telefono: 15565594131


E)- Ahora vamos a crear un handler para posts (de posteos no del metodo post):
  1- En la hoja de postHandler vamos a colocar un handler con su status y su mensaje, recordar exportarlo. 

  2- Solicionar problema

F)- A continuación vamos a crear la base de datos llamada repaso-pi.
  1- Vamos a crear un archivo dentro de la carpeta src llamado db.js, este archivo tendrá toda la responsabilidad de tener toda la configuración de la base de datos (como app tiene la responsabilidad de contener la configuracion de nuestro servidor).
  2- Importante visitar la fuente oficial de Sequelize donde nos presenta 3 tipos de caminos para conectar nuestro back a la base de datos, además de presenntarnos el paso a paso. 
  3- Una vez que eligamos una opcion, copiamos y pegamos (de momento) y por debajo exportamos lo ya detallado con el nombre de conn (algo como conexión).
  4- Una vez que tengamos el archivo de: db.js listo, lo que vamos a hacer es: importar en el archivo api/index.js. Lo pondremos en este archivo ya que en este index, el puerto estará escuchando. 

  5-Importante: Sequelize tiene un método llamado Sync. Este método sirve para sincronizar todos los datos cuando se levante nuestro servidor. Entonces colocaremos que, a la variable conn, le asignaremos el valor de este metodo llamado sync y le diremos que tenga el force in true, es decir que todas las tablas existentes serán eliminadas y se crearán nuevamente de acuerdo a los modelos definidos en el código.

Es importante tener precaución al utilizar force:true, ya que esto puede llevar a la pérdida de datos existentes en la base de datos. Se suele utilizar en entornos de desarrollo o cuando se está modificando la estructura de la base de datos de manera significativa. En entornos de producción, generalmente se evita el uso de force:true para no perder datos valiosos.

¿Cuando utilizar orce: true o force:false?
La decisión de usar force:true o force:false al sincronizar modelos con la base de datos depende de la situación y del entorno en el que estás trabajando. Aquí te doy algunas pautas para ayudarte a tomar esa decisión:

    Desarrollo vs. Producción:
        En entornos de desarrollo, es más común usar force:true para que la base de datos se reemplace o se actualice cada vez que cambies la estructura del modelo. Esto es útil mientras estás iterando y haciendo cambios frecuentes a los modelos.
        En entornos de producción, generalmente es aconsejable utilizar force:false. Esto evitará que se pierdan datos existentes en la base de datos durante la sincronización. En lugar de recrear las tablas, Sequelize realizará cambios incrementales para reflejar las actualizaciones en los modelos.

    Cambios en el Modelo:
        Si estás realizando cambios significativos en la estructura de los modelos (agregando o eliminando campos importantes), puede ser útil utilizar force:true en un entorno de desarrollo para asegurarte de que los cambios se reflejen correctamente en la base de datos.
        En situaciones donde solo estás realizando cambios menores o no críticos en los modelos, es preferible usar force:false para evitar reemplazar la base de datos completa.

    Respaldo de Datos:
        Antes de usar force:true, asegúrate de tener copias de seguridad de tus datos importantes, especialmente si estás en un entorno de producción. Esto te permitirá restaurar los datos en caso de que se pierdan debido a la sincronización.

    Migraciones:
        En lugar de depender completamente de force:true, considera utilizar herramientas de migración como "sequelize-cli" para aplicar cambios en la base de datos de manera controlada. Las migraciones te permiten realizar cambios específicos en la estructura de la base de datos sin afectar los datos existentes.

En resumen, force:true puede ser útil durante el desarrollo para realizar cambios rápidos en la estructura de la base de datos, mientras que force:false es más seguro para evitar la pérdida de datos en entornos de producción. En cualquier caso, es esencial comprender las implicaciones y tener precaución al tomar esta decisión.

force:true si migramos datos en una empresa con muchos datos chau, nos mandan a la hoguera derecho.

6- Notar que al tener la constante sequelize como la completamos originalmente:

  const sequelize = new Sequelize("postgres://postgres:postgres@localhost:5432/repaso-pi")

Tenemos todos los datos al descubierto y vulnerables frente a todo aquel que quiera atentar contra nuestra bd. Para darle una solución a este inconveniento, crear un archivo llamado ".env" dicho archivo tiene que estar dentro de la carpeta api pero afuera de todas las otras, en este archivo colocaremos todas nuestras credenciales. Esto tambien se podría solucionar creando un archivo .js comun y agregandolo al gitignore para que tenga un poco mas de seguridad, pero lo recomendado es el archivo .env 
7- Vamos a requerir el archivo .env en el archivo encargado de la configuracion de la base de datos (db.js) para ello:

00:32







